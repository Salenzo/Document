\chapter{函数}
\newpage

\section{引用}

引用用 \& 标记，用来为储存器提供\textbf{别名}。

\begin{lstlisting}[frame=shadowbox]
    int x;
    int& ref = x;
\end{lstlisting}

分配了一个 int 单元，它拥有两个名字：x, ref。

\subsection{引用调用}

对函数参数用 \& 作为引用参数，将获得\textbf{引用调用}。
在引用调用中，引用参数将实际的实参传给函数，而不是实参的拷贝。
而默认的调用方式为传值引用。

\begin{lstlisting}[frame=shadowbox]
    void swap(int& a,int& b){
        int t;
        t = a;
        a = b;
        b = t;
    }
\end{lstlisting}

使用后，swap 函数的参数直接对应 main 中使用的 i 和 j 的储存空间，而不是拷贝。

\newpage

\subsection{引用返回}

\begin{lstlisting}[frame=shadowbox]
    return expression;    
\end{lstlisting}

默认情况下，函数返回时， expression 被求值，并将值拷贝到临时储存空间，即\text{传值返回}。

而引用返回中，返回值不再拷贝到临时储存空间，甚至 return 语句所用的储存单元对调用者而言都是可访问的。

\begin{lstlisting}[frame=shadowbox]
    int& val(){
        return i;
    }    
\end{lstlisting}

函数中返回引用 i 的引用，直接将值传入到调用者中。与传值返回不同，仅产生一个副本。

\section{内联函数}

关键字 \textbf{inline} 在函数\textbf{声明}（不能出现在定义部分）用来请求将函数用内联方式展开，即在每个调用函数的地方插入函数实现代码。

\section{函数默认参数}

\textbf{所有}没有默认值的参数都要放在函数列表的开始部分，然后才是有默认值的函数。

\section{函数重载}

在\textbf{参数个数或类型}有区别时，同一范围内允许使用相同签名的函数，称 函数名 被重载。
重载函数用来对具有相似行为而数据类型不同的操作提供一个通用名称。

\subsection{函数签名}

重载函数有不同的\textbf{函数签名}：

\begin{enumerate}
    \item 函数名
    \item 参数个数、数据类型和顺序
\end{enumerate}

\section{new delete 操作符}

\begin{enumerate}
    \item new: 分配一个单元
    \item new[]: 分配多个单元（数组）
    \item delete: 释放 new 分配的单元
    \item delete[]: 释放 new[] 分配的单元
\end{enumerate}

new[] 分配了数组后，将第一个单元的地址保存到指向分配的储存空间的指针中。

\section{友元}

在当前类外定义的、不属于当前类中的函数也可以在类中声明为友元函数，可以访问当前类的\textbf{所有}成员。

\begin{enumerate}
    \item 友元关系是单向的
    \item 友元关系不能传递
\end{enumerate}

\section{异常处理}

关键字：
\begin{enumerate}
    \item try
    \item catch
    \item throw
\end{enumerate}

catch 块定义在 try 块之后，因为例外在 try 块中抛出。
例外和不同捕捉器的匹配依靠\textbf{类型}判断来进行。
catch 块提示用户例外后，块中的 continue 将重新返回到 try。
throw 不带任何参数，重新抛出异常给上级处理。

\newpage